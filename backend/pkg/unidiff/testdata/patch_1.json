{
  "message": "remove fuse-client",
  "patches": [
    "diff --git a/client/fuse-client/build-and-upload.sh b/client/fuse-client/build-and-upload.sh\ndeleted file mode 100644\nindex a1617d2..0000000\n--- a/client/fuse-client/build-and-upload.sh\n+++ /dev/null\n@@ -1,81 +0,0 @@\n-#!/usr/bin/env bash\n-\n-set -euo pipefail\n-set -x\n-\n-VERSION=\"v0.3.2\"\n-VERSION_WITHOUT_V=\"${VERSION/v/}\"\n-HOMEBREW_TAP_REPO_PATH=\"${HOME}/src/driva-dev-homebrew-tap\"\n-\n-archive() {\n-  INPUT=$1\n-  OUTPUT=$2\n-  tar -s \"/${INPUT}/sturdy/\" -zcvf $OUTPUT $INPUT LICENSE\n-}\n-\n-build_upload() {\n-  GOOS=$1\n-  GOARCH=$2\n-  BIN_NAME=\"sturdy-$VERSION-$GOOS-$GOARCH\"\n-  TAR_NAME=\"sturdy-$VERSION-$GOOS-$GOARCH.tar.gz\"\n-\n-  # Build binary\n-  GOOS=$GOOS GOARCH=$GOARCH go build -o \"${BIN_NAME}\" mash/client/fuse-client/cmd/fuse-client\n-\n-  # Build archived version (to use with Homebrew)\n-  archive $BIN_NAME $TAR_NAME\n-\n-  # Upload both\n-  aws s3 cp --quiet ${BIN_NAME} \"s3://getsturdy.com/client/${BIN_NAME}\"\n-  aws s3 cp --quiet ${TAR_NAME} \"s3://getsturdy.com/client/${TAR_NAME}\"\n-\n-  echo ${TAR_NAME};\n-}\n-\n-# Build and upload files to S3\n-DARWIN_AMD64_TAR_NAME=$(build_upload darwin amd64)\n-LINUX_AMD64_TAR_NAME=$(build_upload linux amd64)\n-\n-# Update InstallClient.vue version number\n-update_web_install() {\n-  t=$(mktemp)\n-  cat ../../web/src/components/install/InstallClient.vue | \\\n-    sed \"s/latestVersion: \\\".*\\\"/latestVersion: \\\"${VERSION}\\\"/\" > $t\n-  mv $t ../../web/src/components/install/InstallClient.vue\n-}\n-\n-update_web_install\n-\n-create_formula() {\n-  cat > \"${HOMEBREW_TAP_REPO_PATH}/Formula/sturdy.rb\" <<EOF\n-class Sturdy < Formula\n-    desc \"Sturdy Client\"\n-    homepage \"https://getsturdy.com/\"\n-    version \"${VERSION_WITHOUT_V}\"\n-    bottle :unneeded\n-\n-    if OS.mac?\n-        url \"https://getsturdy.com/client/${DARWIN_AMD64_TAR_NAME}\"\n-        sha256 \"$(sha256sum ${DARWIN_AMD64_TAR_NAME} | awk '{print $1}')\"\n-    elsif OS.linux?\n-        url \"https://getsturdy.com/client/${LINUX_AMD64_TAR_NAME}\"\n-        sha256 \"$(sha256sum ${LINUX_AMD64_TAR_NAME} | awk '{print $1}')\"\n-    end\n-\n-    def install\n-        bin.install \"sturdy\"\n-    end\n-end\n-EOF\n-}\n-\n-commit_and_push_formula() {\n-  git -C \"$HOMEBREW_TAP_REPO_PATH\" diff\n-  git -C \"$HOMEBREW_TAP_REPO_PATH\" add Formula/sturdy.rb\n-  git -C \"$HOMEBREW_TAP_REPO_PATH\" commit -m \"Sturdy ${VERSION}\"\n-  git -C \"$HOMEBREW_TAP_REPO_PATH\" push\n-}\n-\n-# Push update to Homebrew Tap\n-create_formula\n-commit_and_push_formula\n",
    "diff --git a/client/fuse-client/cmd/fuse-client/daemon.go b/client/fuse-client/cmd/fuse-client/daemon.go\ndeleted file mode 100644\nindex ee2c945..0000000\n--- a/client/fuse-client/cmd/fuse-client/daemon.go\n+++ /dev/null\n@@ -1,146 +0,0 @@\n-package main\n-\n-import (\n-\t\"context\"\n-\t\"log\"\n-\tproto \"mash/api/filesystem\"\n-\t\"mash/client/fuse-client/config\"\n-\t\"mash/client/fuse-client/fuse\"\n-\tfusegrpc \"mash/client/fuse-client/grpc\"\n-\t\"mash/client/fuse-client/local\"\n-\t\"mash/client/fuse-client/pkg/api\"\n-\t\"os\"\n-\t\"os/signal\"\n-\t\"os/user\"\n-\t\"path\"\n-\t\"sync\"\n-\t\"syscall\"\n-\n-\t\"google.golang.org/grpc/metadata\"\n-\n-\t\"github.com/google/uuid\"\n-\t\"github.com/johnsiilver/getcert\"\n-\t\"google.golang.org/grpc\"\n-\t\"google.golang.org/grpc/credentials\"\n-)\n-\n-// daemon starts and manages all fuse mounts\n-//\n-// It's intended to be run in a subprocess by \"./fuse-client start\"\n-//\n-// Log lines prefixed with [STATUS] will be seen by the user in the \"start\" and \"stop\"\n-// commands. Other logs will only be visible when \"./fuse-client daemon\" is executed directly.\n-func daemon(conf *config.Config) {\n-\t// Prepare logfile\n-\tlogPath := os.TempDir() + \"sturdy.log\"\n-\tlog.Printf(\"Will write logs to %s\", logPath)\n-\tlogFile, err := os.OpenFile(logPath, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)\n-\tif err != nil {\n-\t\tlog.Fatalf(\"error opening log file: %v\", err)\n-\t}\n-\tdefer logFile.Close()\n-\n-\tu, err := user.Current()\n-\tif err != nil {\n-\t\tlog.Fatal(\"unable to get current user: %w\", err)\n-\t}\n-\n-\tlocalReadWriterPathPrefix := path.Join(u.HomeDir, \".cache\", \"sturdy\")\n-\tlog.Printf(\"Using %s for .sturdyignore\", localReadWriterPathPrefix)\n-\n-\tvar opts []grpc.DialOption\n-\tif conf.InsecureRemote {\n-\t\topts = append(opts, grpc.WithInsecure())\n-\t} else {\n-\t\ttlsCert, _, err := getcert.FromTLSServer(conf.Remote, false)\n-\t\tif err != nil {\n-\t\t\tlog.Println(err)\n-\t\t\tos.Exit(1)\n-\t\t}\n-\t\topts = append(opts, grpc.WithTransportCredentials(credentials.NewServerTLSFromCert(&tlsCert)))\n-\t}\n-\n-\t// Attach authentication metadata on every request\n-\topts = append(opts, grpc.WithChainUnaryInterceptor(buildAuthMiddleware(conf.Auth)))\n-\n-\tserverConnection, err := grpc.Dial(conf.Remote, opts...)\n-\tif err != nil {\n-\t\tlog.Println(err)\n-\t\tos.Exit(1)\n-\t}\n-\n-\tvar bootupWG sync.WaitGroup\n-\n-\tfor _, view := range conf.Views {\n-\t\tbootupWG.Add(1)\n-\t\tgo func(v config.ViewConfig) {\n-\t\t\terr := mountView(serverConnection, conf, v, localReadWriterPathPrefix, &bootupWG)\n-\t\t\tif err != nil {\n-\t\t\t\tlog.Fatalln(err)\n-\t\t\t}\n-\t\t}(view)\n-\t}\n-\n-\tsigUsr1 := make(chan os.Signal, 1)\n-\tsignal.Notify(sigUsr1, syscall.SIGUSR1)\n-\n-\tsigShutdown := make(chan os.Signal, 1)\n-\tsignal.Notify(sigShutdown, syscall.SIGTERM, syscall.SIGINT)\n-\n-\tlog.Println(\"Parent PID\", syscall.Getppid())\n-\n-\tlog.Println(\"Waiting for all views to be mounted\")\n-\tbootupWG.Wait()\n-\tlog.Println(\"[STATUS] All ready\")\n-\n-\t// Wait forever\n-forever:\n-\tfor {\n-\t\tselect {\n-\t\tcase <-sigUsr1:\n-\t\t\tlog.SetOutput(logFile)\n-\t\t\tlog.Println(\"Received SIGUSR1, entering background mode :-)\")\n-\n-\t\tcase <-sigShutdown:\n-\t\t\tlog.Println(\"Received shutdown signal, stopping\")\n-\t\t\tbreak forever\n-\t\t}\n-\t}\n-}\n-\n-func mountView(serverConnection *grpc.ClientConn, conf *config.Config, view config.ViewConfig, localReadWriterPathPrefix string, wg *sync.WaitGroup) error {\n-\tviewUUID := uuid.MustParse(view.ID)\n-\tremoteStore := fusegrpc.NewGrpcClient(viewUUID, proto.NewFileSystemClient(serverConnection))\n-\n-\tlocalStore := local.NewLocalReadWriter(path.Join(localReadWriterPathPrefix, view.ID))\n-\n-\tlog.Printf(\"Mounting view %s to %s\", viewUUID.String(), view.Path)\n-\n-\tapiClient := api.NewHttpApiClient(conf)\n-\n-\terr := fuse.Run(fuse.Config{\n-\t\tMountpoint: view.Path,\n-\t\tViewID:     view.ID,\n-\t\tAPIHost:    conf.APIRemote,\n-\t\tAuthToken:  conf.Auth,\n-\t},\n-\t\tapiClient,\n-\t\tremoteStore,\n-\t\tlocalStore,\n-\t\twg)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-\n-func buildAuthMiddleware(authToken string) grpc.UnaryClientInterceptor {\n-\treturn func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {\n-\t\tctx = metadata.AppendToOutgoingContext(ctx, \"auth\", authToken)\n-\t\terr := invoker(ctx, method, req, reply, cc, opts...)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\treturn nil\n-\t}\n-}\n",
    "diff --git a/client/fuse-client/cmd/fuse-client/init.go b/client/fuse-client/cmd/fuse-client/init.go\ndeleted file mode 100644\nindex e3e4d9a..0000000\n--- a/client/fuse-client/cmd/fuse-client/init.go\n+++ /dev/null\n@@ -1,76 +0,0 @@\n-package main\n-\n-import (\n-\t\"fmt\"\n-\t\"log\"\n-\n-\t\"mash/client/fuse-client/config\"\n-\t\"mash/client/fuse-client/pkg/initView\"\n-)\n-\n-// User friendly init\n-//\n-// If auth is missing it will run the auth flow.\n-// If the mount point path is already configured with a view it will not create a new one\n-// It will restart Sturdy daemon only if needed\n-func initSmart(conf *config.Config, configPath string, args []string) {\n-\tif len(args) < 2 {\n-\t\tlog.Fatalln(\"❌ Unexpected number of arguments\")\n-\t}\n-\n-\tif conf.Auth == \"\" {\n-\t\tauth(conf, configPath)\n-\t} else {\n-\t\tfmt.Println(\"🔑 Already authenticated\")\n-\t}\n-\n-\tnewlyCreated := createView(conf, configPath, args)\n-\n-\tif isRunning() && !newlyCreated {\n-\t\tprintReady(args)\n-\t\treturn\n-\t}\n-\tif !isRunning() {\n-\t\tserverStart(configPath)\n-\t\tprintReady(args)\n-\t\treturn\n-\t}\n-\n-\tfmt.Println(\"🔁 Restarting Sturdy\")\n-\tserverStop()\n-\tserverStart(configPath)\n-\tprintReady(args)\n-}\n-\n-func printReady(args []string) {\n-\tfmt.Printf(\"✅ Your new codebase view is now ready at: %s\\n\", args[1])\n-}\n-\n-func createView(conf *config.Config, configPath string, args []string) (newConfig *config.Config, newlyCreated bool) {\n-\tmountPath := args[1]\n-\n-\texists := false\n-\tfor _, v := range conf.Views {\n-\t\tif v.Path == mountPath {\n-\t\t\texists = true\n-\t\t}\n-\t}\n-\n-\tif exists {\n-\t\treturn conf, false\n-\t}\n-\n-\tcodebaseID := args[0]\n-\n-\tviewID, err := initView.CreateWorkspaceAndView(conf.APIRemote, conf.Auth, codebaseID, mountPath)\n-\tif err != nil {\n-\t\tlog.Fatalln(err)\n-\t}\n-\n-\tnewConfig, err = config.AddMount(configPath, viewID, mountPath)\n-\tif err != nil {\n-\t\tlog.Fatalln(err)\n-\t}\n-\n-\treturn newConfig, true\n-}\n",
    "diff --git a/client/fuse-client/cmd/fuse-client/main.go b/client/fuse-client/cmd/fuse-client/main.go\ndeleted file mode 100644\nindex be24dba..0000000\n--- a/client/fuse-client/cmd/fuse-client/main.go\n+++ /dev/null\n@@ -1,77 +0,0 @@\n-package main\n-\n-import (\n-\t\"flag\"\n-\t\"fmt\"\n-\t\"log\"\n-\t\"mash/client/fuse-client/config\"\n-\t\"os\"\n-\t\"path\"\n-)\n-\n-func main() {\n-\tif len(os.Args) < 2 {\n-\t\tfmt.Println(\"This is the Sturdy fuse client\")\n-\t\tfmt.Println(\"\")\n-\t\tfmt.Println(\"No subcommand provided\")\n-\t\tfmt.Println(\"\")\n-\t\tfmt.Println(\"Available commands:\")\n-\t\tfmt.Println(\"\\tstart\\tstart the Sturdy daemon on the background\")\n-\t\tfmt.Println(\"\\tstop\\tstop the Sturdy daemon\")\n-\t\tfmt.Println(\"\\tstatus\\tget the current status of Sturdy\")\n-\t\tfmt.Println(\"\\tauth\\tauthenticate yourself with Sturdy\")\n-\t\tfmt.Println(\"\\tinit\\tconfigure a new codebase to be used with your workstation\")\n-\t\tfmt.Println(\"\")\n-\t\tfmt.Println(\"Advanced commands:\")\n-\t\tfmt.Println(\"\\tdaemon\\trun the Sturdy daemon in the foreground, useful for debugging :-)\")\n-\t\tos.Exit(1)\n-\t\treturn\n-\t}\n-\n-\thome, err := os.UserHomeDir()\n-\tif err != nil {\n-\t\tlog.Println(\"Could not find user home dir\")\n-\t\tos.Exit(1)\n-\t\treturn\n-\t}\n-\n-\t// len is 2 if there is only a subcommand provided, and no additional flags\n-\tvar args []string\n-\tif len(os.Args) > 2 {\n-\t\targs = os.Args[2:]\n-\t}\n-\n-\tfs := flag.FlagSet{}\n-\tconfigPath := fs.String(\"config\", path.Join(home, \".sturdy\"), \"Path to your Sturdy configuration file\")\n-\terr = fs.Parse(args)\n-\tif err != nil {\n-\t\tlog.Println(\"Failed to parse flags\", err)\n-\t\tos.Exit(1)\n-\t\treturn\n-\t}\n-\n-\t// Remaining arguments after flags have been parseds\n-\targs = fs.Args()\n-\n-\tconf, err := config.ReadConfig(*configPath)\n-\tif err != nil {\n-\t\tlog.Println(err)\n-\t\tos.Exit(1)\n-\t\treturn\n-\t}\n-\n-\tswitch os.Args[1] {\n-\tcase \"start\":\n-\t\tserverStart(*configPath)\n-\tcase \"auth\":\n-\t\tauth(conf, *configPath)\n-\tcase \"stop\":\n-\t\tserverStop()\n-\tcase \"status\":\n-\t\tserverStatus()\n-\tcase \"daemon\":\n-\t\tdaemon(conf)\n-\tcase \"init\":\n-\t\tinitSmart(conf, *configPath, args)\n-\t}\n-}\n",
    "diff --git a/client/fuse-client/cmd/fuse-client/output b/client/fuse-client/cmd/fuse-client/output\ndeleted file mode 100644\nindex e69de29..0000000\n",
    "diff --git a/client/fuse-client/cmd/fuse-client/server.go b/client/fuse-client/cmd/fuse-client/server.go\ndeleted file mode 100644\nindex 064ac35..0000000\n--- a/client/fuse-client/cmd/fuse-client/server.go\n+++ /dev/null\n@@ -1,198 +0,0 @@\n-package main\n-\n-import (\n-\t\"bufio\"\n-\t\"errors\"\n-\t\"fmt\"\n-\t\"io/ioutil\"\n-\t\"log\"\n-\t\"os\"\n-\t\"os/exec\"\n-\t\"path\"\n-\t\"strconv\"\n-\t\"strings\"\n-\t\"syscall\"\n-\t\"time\"\n-)\n-\n-func pidFile() (string, error) {\n-\thome, err := os.UserHomeDir()\n-\tif err != nil {\n-\t\treturn \"\", fmt.Errorf(\"failed to find home dir: %w\", err)\n-\t}\n-\treturn path.Join(home, \".sturdy.pid\"), nil\n-}\n-\n-// serverStart starts a new background daemon\n-// During the bootup phase of the daemon, log messages (stderr) from the daemon\n-// are forwarded to the user (on stdout)\n-func serverStart(configPath string) {\n-\tfmt.Println(\"🔌 Starting Sturdy\")\n-\n-\tif isRunning() {\n-\t\tlog.Printf(\"Sturdy is already running, stop it with: %s stop\", os.Args[0])\n-\t\tos.Exit(1)\n-\t\treturn\n-\t}\n-\n-\tcmd := exec.Command(os.Args[0], \"daemon\", \"--config\", configPath)\n-\tstderr, err := cmd.StderrPipe()\n-\tif err != nil {\n-\t\tlog.Println(\"failed to pipe?\")\n-\t\tlog.Fatal(err)\n-\t}\n-\n-\terr = cmd.Start()\n-\tif err != nil {\n-\t\tlog.Println(\"failed to start subprocess\")\n-\t\tlog.Fatal(err)\n-\t}\n-\n-\tstderrreader := bufio.NewReader(stderr)\n-\tlines := []string{}\n-\tfor {\n-\t\tline, err := stderrreader.ReadString('\\n')\n-\t\tlines = append(lines, line)\n-\t\tif err != nil {\n-\t\t\tfor _, l := range lines {\n-\t\t\t\tlog.Print(l)\n-\t\t\t}\n-\n-\t\t\tlog.Println(\"daemon stopped unexpectedly\")\n-\t\t\tlog.Fatalln(err)\n-\t\t}\n-\n-\t\tline = strings.TrimSpace(line)\n-\t\tstatusKey := \"[STATUS]\"\n-\t\tidx := strings.Index(line, statusKey)\n-\t\tif idx > -1 {\n-\t\t\tfmt.Println(\"ℹ️\", line[idx+len(statusKey):])\n-\t\t}\n-\n-\t\tif strings.Contains(line, \"[STATUS] All ready\") {\n-\t\t\tif err := stderr.Close(); err != nil {\n-\t\t\t\tlog.Println(err)\n-\t\t\t}\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\n-\t// TODO: Signal from daemon to the user that everything was successful?\n-\n-\t// Write pid to pidfile\n-\tpf, err := pidFile()\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-\terr = ioutil.WriteFile(pf, []byte(fmt.Sprintf(\"%d\", cmd.Process.Pid)), 0666)\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-\n-\t// Send SIGUSR1 to daemon to tell it to go into background mode\n-\t// And not write anything to stderr or stdout anymore\n-\terr = sendGoToBackground(cmd.Process)\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-\n-\tfmt.Printf(\"ℹ️ To stop Sturdy run: %s stop\\n\", os.Args[0])\n-\tfmt.Println(\"🚀 Sturdy is now running, happy hacking!\")\n-}\n-\n-func sendGoToBackground(p *os.Process) error {\n-\terr := p.Signal(syscall.SIGUSR1)\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"failed to tell process to go to background: %w\", err)\n-\t}\n-\treturn nil\n-}\n-\n-func serverStop() {\n-\tlog.Println(\"💡 Stopping Sturdy\")\n-\n-\tpid, err := getPid()\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-\tproc, err := os.FindProcess(pid)\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-\n-\terr = proc.Signal(syscall.SIGTERM)\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-\n-\tawaitTermination(pid, 2*time.Second)\n-\tlog.Println(\"💡 Sturdy has been stopped\")\n-}\n-\n-func awaitTermination(pid int, timeout time.Duration) {\n-\tfor start := time.Now(); time.Since(start) < timeout; {\n-\t\terr := syscall.Kill(pid, syscall.Signal(0))\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\ttime.Sleep(timeout / 8)\n-\t}\n-\tproc, err := os.FindProcess(pid)\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-\terr = proc.Kill()\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-}\n-\n-func serverStatus() {\n-\tif !isRunning() {\n-\t\tlog.Println(\"Sturdy is not running\")\n-\t\treturn\n-\t}\n-\n-\t// TODO: Send a signal to the daemon and expect a reply?\n-\tlog.Println(\"Sturdy is probably running\")\n-}\n-\n-func isRunning() bool {\n-\tpid, err := getPid()\n-\tif err != nil {\n-\t\tif errors.Is(err, pidFileNotFound) {\n-\t\t\treturn false\n-\t\t}\n-\t\tlog.Fatal(err)\n-\t}\n-\tproc, err := os.FindProcess(pid)\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-\terr = proc.Signal(syscall.Signal(0))\n-\tif err != nil {\n-\t\treturn false\n-\t}\n-\treturn true\n-}\n-\n-var pidFileNotFound = errors.New(\"pid file not found\")\n-\n-func getPid() (int, error) {\n-\tpf, err := pidFile()\n-\tif err != nil {\n-\t\treturn 0, fmt.Errorf(\"unable to find pidfile: %w\", err)\n-\t}\n-\tcontents, err := ioutil.ReadFile(pf)\n-\tif err != nil {\n-\t\tif os.IsNotExist(err) {\n-\t\t\treturn 0, pidFileNotFound\n-\t\t}\n-\t\treturn 0, fmt.Errorf(\"unable to read pidfile: %w\", err)\n-\t}\n-\tpid, err := strconv.Atoi(string(contents))\n-\tif err != nil {\n-\t\treturn 0, fmt.Errorf(\"unable to parse pidfile: %w\", err)\n-\t}\n-\treturn pid, nil\n-}\n",
    "diff --git a/client/fuse-client/config-example.json b/client/fuse-client/config-example.json\ndeleted file mode 100644\nindex d0b03e1..0000000\n--- a/client/fuse-client/config-example.json\n+++ /dev/null\n@@ -1,13 +0,0 @@\n-{\n-    \"remote\": \"127.0.0.1:3001\",\n-    \"insecure-remote\": true,\n-    \"api-remote\": \"http://127.0.0.1:3000\",\n-    \"auth\": \"8e63f0c3-b245-41ba-a2e4-c92aac971889\",\n-    \"client-id\": \"388ede02-8f4b-4d5b-b407-fa4f24b5e17e\",\n-    \"views\": [\n-        {\n-            \"id\": \"f4fdc072-b3df-4d4a-bd37-cfb850901ee6\",\n-            \"path\": \"/Users/gustav/masher\"\n-        }\n-    ]\n-}\n",
    "diff --git a/client/fuse-client/fuse/dir.go b/client/fuse-client/fuse/dir.go\ndeleted file mode 100644\nindex 34e7f06..0000000\n--- a/client/fuse-client/fuse/dir.go\n+++ /dev/null\n@@ -1,504 +0,0 @@\n-package fuse\n-\n-import (\n-\t\"bazil.org/fuse\"\n-\t\"bazil.org/fuse/fs\"\n-\t\"context\"\n-\t\"errors\"\n-\t\"fmt\"\n-\t\"log\"\n-\tfileproto \"mash/api/files\"\n-\t\"mash/client/fuse-client/inode\"\n-\t\"os\"\n-\t\"sync\"\n-)\n-\n-// Dir implements both Node and Handle for the root directory.\n-type DirNode struct {\n-\tinode uint64\n-\tname  string\n-\tmode  os.FileMode\n-\n-\tfs *FS\n-\n-\tchildrenMX                  sync.Mutex\n-\tforceReadChildrenFromRemote bool\n-\n-\thasListedChildrenFromRemote bool\n-}\n-\n-var _ fs.Node = (*DirNode)(nil)\n-\n-func (d *DirNode) Attr(ctx context.Context, a *fuse.Attr) error {\n-\ta.Inode = d.inode // is generated automatically if set to 0\n-\ta.Mode = d.mode\n-\ta.Uid = uint32(os.Getuid())\n-\ta.Gid = uint32(os.Getgid())\n-\treturn nil\n-}\n-\n-var _ fs.HandleReadDirAller = (*DirNode)(nil)\n-\n-func (d *DirNode) ReadDirAll(ctx context.Context) ([]fuse.Dirent, error) {\n-\n-\tvar didFullRefreshFromRemote bool\n-\tremoteIds := make(map[uint64]struct{})\n-\n-\t// Read from remote\n-\tif !d.hasListedChildrenFromRemote || d.forceReadChildrenFromRemote {\n-\t\tdidFullRefreshFromRemote = true\n-\n-\t\tstore, isRemote, err := d.fs.StoreForInode(d.inode)\n-\t\tif err != nil && errors.Is(err, inode.NotFoundErr) {\n-\t\t\treturn nil, fuse.ENOENT\n-\t\t}\n-\t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"failed to get store for inode: %w\", err)\n-\t\t}\n-\n-\t\tp, err := d.fs.FullName(d.inode)\n-\t\tif err != nil && errors.Is(err, inode.NotFoundErr) {\n-\t\t\treturn nil, fuse.ENOENT\n-\t\t}\n-\t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"failed to get full name for inode: %w\", err)\n-\t\t}\n-\n-\t\tfiles, err := store.ListDir(p)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\t// Also read from local\n-\t\tif isRemote {\n-\t\t\tlocalFiles, err := d.fs.localStore.ListDir(p)\n-\t\t\tif err != nil && !os.IsNotExist(err) {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t\tfiles = append(files, localFiles...)\n-\t\t}\n-\n-\t\tfor _, file := range files {\n-\t\t\t// Already existed?\n-\t\t\t// TODO: What happens if the file has changed type?\n-\t\t\tif n, err := d.fs.inodestore.LookupChild(d.inode, file.Name); err == nil {\n-\t\t\t\tremoteIds[n] = struct{}{}\n-\t\t\t\tcontinue\n-\t\t\t}\n-\n-\t\t\tswitch file.Type {\n-\t\t\tcase fileproto.File_Normal:\n-\t\t\t\t// TODO: Keep name in either inode or file object, not both\n-\t\t\t\tn := &DataNode{\n-\t\t\t\t\tname: file.Name,\n-\t\t\t\t\tfs:   d.fs,\n-\t\t\t\t\tstat: file.Stat,\n-\t\t\t\t}\n-\t\t\t\tchildInode, err := d.fs.inodestore.Add(d.inode, file.Name, n)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn nil, err\n-\t\t\t\t}\n-\t\t\t\tn.inode = childInode\n-\t\t\t\tremoteIds[childInode] = struct{}{}\n-\n-\t\t\tcase fileproto.File_Directory:\n-\t\t\t\tn := &DirNode{\n-\t\t\t\t\tname: file.Name,\n-\t\t\t\t\tfs:   d.fs,\n-\t\t\t\t\tmode: os.FileMode(file.Stat.Mode),\n-\t\t\t\t}\n-\t\t\t\tchildInode, err := d.fs.inodestore.Add(d.inode, file.Name, n)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn nil, err\n-\t\t\t\t}\n-\t\t\t\tn.inode = childInode\n-\t\t\t\tremoteIds[childInode] = struct{}{}\n-\n-\t\t\tcase fileproto.File_Link:\n-\t\t\t\tn := &Link{\n-\t\t\t\t\tname:   file.Name,\n-\t\t\t\t\ttarget: string(file.Data),\n-\t\t\t\t\tfs:     d.fs,\n-\t\t\t\t}\n-\t\t\t\tchildInode, err := d.fs.inodestore.Add(d.inode, file.Name, n)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn nil, err\n-\t\t\t\t}\n-\t\t\t\tn.inode = childInode\n-\t\t\t\tremoteIds[childInode] = struct{}{}\n-\t\t\t}\n-\t\t}\n-\n-\t\td.hasListedChildrenFromRemote = true\n-\t\td.forceReadChildrenFromRemote = false\n-\t}\n-\n-\tdirDirs := []fuse.Dirent{\n-\t\t{\n-\t\t\tName: \".\",\n-\t\t\tType: fuse.DT_Dir,\n-\t\t},\n-\t\t{\n-\t\t\tName: \"..\",\n-\t\t\tType: fuse.DT_Dir,\n-\t\t},\n-\t}\n-\n-\tchildInodes, err := d.fs.inodestore.GetChildren(d.inode)\n-\tif err != nil {\n-\t\tif errors.Is(err, inode.ParentDoesNotHaveChildrenErr) {\n-\t\t\treturn dirDirs, nil\n-\t\t} else {\n-\t\t\treturn nil, err\n-\t\t}\n-\t}\n-\n-\tfor _, childInode := range childInodes {\n-\t\tif didFullRefreshFromRemote {\n-\t\t\t// Remove local entries that didn't exist remotely\n-\t\t\tif _, ok := remoteIds[childInode]; !ok {\n-\t\t\t\terr := d.fs.inodestore.Remove(childInode)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn nil, fmt.Errorf(\"remove removed file failed: %w\", err)\n-\t\t\t\t}\n-\t\t\t\td.fs.invalidations <- childInode\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t}\n-\n-\t\tc, err := d.fs.inodestore.Get(childInode)\n-\t\tif err != nil {\n-\t\t\tlog.Println(err)\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\tdirDirs = append(dirDirs, Dirent(childInode, c))\n-\t}\n-\n-\treturn dirDirs, nil\n-}\n-\n-func Dirent(inode uint64, file *inode.Node) fuse.Dirent {\n-\tvar tp fuse.DirentType\n-\tvar name string\n-\n-\tswitch v := file.FuseNode.(type) {\n-\tcase *DirNode:\n-\t\ttp = fuse.DT_Dir\n-\t\tname = v.name\n-\tcase *Link:\n-\t\ttp = fuse.DT_Link\n-\t\tname = v.name\n-\tcase *DataNode:\n-\t\ttp = fuse.DT_Link\n-\t\tname = v.name\n-\tdefault:\n-\t\tpanic(\"unknown type\")\n-\t}\n-\n-\treturn fuse.Dirent{\n-\t\tInode: inode,\n-\t\tType:  tp,\n-\t\tName:  name,\n-\t}\n-}\n-\n-var _ fs.NodeStringLookuper = (*DirNode)(nil)\n-\n-func (d *DirNode) Lookup(ctx context.Context, name string) (fs.Node, error) {\n-\td.childrenMX.Lock()\n-\tdefer d.childrenMX.Unlock()\n-\n-\tvar didReadAllInLookup bool\n-\n-\tif d.forceReadChildrenFromRemote {\n-\t\t_, err := d.ReadDirAll(ctx)\n-\t\tif err != nil {\n-\t\t\treturn nil, fuse.ENOENT\n-\t\t}\n-\t\tdidReadAllInLookup = true\n-\t}\n-\n-\tfileInode, err := d.fs.inodestore.LookupChild(d.inode, name)\n-\tif err != nil && errors.Is(err, inode.ChildNotFoundErr) {\n-\t\treturn nil, fuse.ENOENT\n-\t}\n-\n-\t// TODO: When this happens, quick Lookup to remotes?\n-\tif (err != nil && errors.Is(err, inode.ParentDoesNotHaveChildrenErr)) && !didReadAllInLookup {\n-\t\t_, err = d.ReadDirAll(ctx)\n-\t\tif err != nil {\n-\t\t\treturn nil, fuse.ENOENT\n-\t\t}\n-\n-\t\t// try again\n-\t\tfileInode, err = d.fs.inodestore.LookupChild(d.inode, name)\n-\t\tif err != nil && errors.Is(err, inode.ParentDoesNotHaveChildrenErr) {\n-\t\t\treturn nil, fuse.ENOENT\n-\t\t}\n-\t\tif err != nil && errors.Is(err, inode.ChildNotFoundErr) {\n-\t\t\treturn nil, fuse.ENOENT\n-\t\t}\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t}\n-\n-\tnode, err := d.fs.inodestore.Get(fileInode)\n-\tif err != nil {\n-\t\treturn nil, fuse.ENOENT\n-\t}\n-\n-\treturn node.FuseNode, err\n-}\n-\n-var _ fs.NodeMkdirer = (*DirNode)(nil)\n-\n-func (d *DirNode) Mkdir(ctx context.Context, req *fuse.MkdirRequest) (fs.Node, error) {\n-\tstore, _, err := d.fs.StoreForInodeAndName(d.inode, req.Name)\n-\tif err != nil && errors.Is(err, inode.NotFoundErr) {\n-\t\treturn nil, fuse.ENOENT\n-\t}\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"failed to get store for dir: %w\", err)\n-\t}\n-\n-\tdirFullName, err := d.fs.FullName(d.inode)\n-\tif err != nil && errors.Is(err, inode.NotFoundErr) {\n-\t\treturn nil, fuse.ENOENT\n-\t}\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"failed to get full name for dir: %w\", err)\n-\t}\n-\n-\terr = store.CreateDir(dirFullName, req.Name, req.Mode)\n-\tif err != nil {\n-\t\tlog.Println(err)\n-\t\treturn nil, err\n-\t}\n-\n-\tn := &DirNode{\n-\t\tfs:   d.fs,\n-\t\tname: req.Name,\n-\t\tmode: req.Mode,\n-\t}\n-\tchildInode, err := d.fs.inodestore.Add(d.inode, req.Name, n)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tn.inode = childInode\n-\n-\treturn n, nil\n-}\n-\n-var _ fs.NodeCreater = (*DirNode)(nil)\n-\n-func (d *DirNode) Create(ctx context.Context, req *fuse.CreateRequest, resp *fuse.CreateResponse) (fs.Node, fs.Handle, error) {\n-\tstore, _, err := d.fs.StoreForInodeAndName(d.inode, req.Name)\n-\tif err != nil && errors.Is(err, inode.NotFoundErr) {\n-\t\treturn nil, nil, fuse.ENOENT\n-\t}\n-\tif err != nil {\n-\t\treturn nil, nil, fmt.Errorf(\"failed to get store for dir: %w\", err)\n-\t}\n-\n-\tdirFullName, err := d.fs.FullName(d.inode)\n-\tif err != nil && errors.Is(err, inode.NotFoundErr) {\n-\t\treturn nil, nil, fuse.ENOENT\n-\t}\n-\tif err != nil {\n-\t\treturn nil, nil, fmt.Errorf(\"failed to get full name for dir: %w\", err)\n-\t}\n-\n-\terr = store.CreateFile(\n-\t\tdirFullName,\n-\t\treq.Name,\n-\t\treq.Mode,\n-\t)\n-\tif err != nil {\n-\t\tlog.Println(err)\n-\t\treturn nil, nil, err\n-\t}\n-\n-\tn := &DataNode{\n-\t\tfs:   d.fs,\n-\t\tname: req.Name,\n-\t}\n-\tchildInode, err := d.fs.inodestore.Add(d.inode, req.Name, n)\n-\tif err != nil {\n-\t\treturn nil, nil, err\n-\t}\n-\tn.inode = childInode\n-\n-\treturn n, n, nil\n-}\n-\n-var _ fs.NodeRemover = (*DirNode)(nil)\n-\n-// Remove removes the entry with the given name from\n-// the receiver, which must be a directory.  The entry to be removed\n-// may correspond to a file (unlink) or to a directory (rmdir).\n-func (d *DirNode) Remove(ctx context.Context, req *fuse.RemoveRequest) error {\n-\tchildNode, err := d.fs.inodestore.LookupChild(d.inode, req.Name)\n-\tif err != nil {\n-\t\tlog.Println(err)\n-\t\treturn err\n-\t}\n-\n-\tstore, _, err := d.fs.StoreForInode(childNode)\n-\tif err != nil && errors.Is(err, inode.NotFoundErr) {\n-\t\treturn fuse.ENOENT\n-\t}\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"failed to get store for inode: %w\", err)\n-\t}\n-\n-\tdirFullName, err := d.fs.FullName(d.inode)\n-\tif err != nil && errors.Is(err, inode.NotFoundErr) {\n-\t\treturn fuse.ENOENT\n-\t}\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"failed to get full name for dir: %w\", err)\n-\t}\n-\n-\t// rmdir\n-\tif req.Dir {\n-\t\terr := store.DeleteDir(dirFullName, req.Name)\n-\t\tif err != nil {\n-\t\t\tlog.Println(err)\n-\t\t\treturn err\n-\t\t}\n-\n-\t} else {\n-\t\t// unlink\n-\t\terr = store.DeleteFile(dirFullName, req.Name)\n-\t\tif err != nil {\n-\t\t\tlog.Println(err)\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\n-\terr = d.fs.inodestore.Remove(childNode)\n-\tif err != nil {\n-\t\tlog.Println(err)\n-\t\treturn err\n-\t}\n-\n-\treturn nil\n-}\n-\n-var _ fs.NodeRenamer = (*DirNode)(nil)\n-\n-func (d *DirNode) Rename(ctx context.Context, req *fuse.RenameRequest, newDir fs.Node) error {\n-\tin, err := d.fs.inodestore.LookupChild(d.inode, req.OldName)\n-\tif err != nil {\n-\t\tlog.Println(err)\n-\t\treturn err\n-\t}\n-\n-\tstore, _, err := d.fs.StoreForInode(in)\n-\tif err != nil && errors.Is(err, inode.NotFoundErr) {\n-\t\treturn fuse.ENOENT\n-\t}\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"failed to get store for inode: %w\", err)\n-\t}\n-\n-\tdirFullName, err := d.fs.FullName(d.inode)\n-\tif err != nil && errors.Is(err, inode.NotFoundErr) {\n-\t\treturn fuse.ENOENT\n-\t}\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"failed to get full name for dir: %w\", err)\n-\t}\n-\n-\tnewDirFullName, err := d.fs.FullName(newDir.(*DirNode).inode)\n-\tif err != nil && errors.Is(err, inode.NotFoundErr) {\n-\t\treturn fuse.ENOENT\n-\t}\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"failed to get full name for new dir: %w\", err)\n-\t}\n-\n-\terr = store.Rename(\n-\t\tdirFullName,\n-\t\treq.OldName,\n-\t\tnewDirFullName,\n-\t\treq.NewName,\n-\t)\n-\tif err != nil {\n-\t\tlog.Println(err)\n-\t\treturn err\n-\t}\n-\n-\t// update name\n-\t// TODO: find a better way?\n-\tnode, err := d.fs.inodestore.GetFuseNode(in)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\tswitch v := node.(type) {\n-\tcase *DataNode:\n-\t\tv.name = req.NewName\n-\tcase *DirNode:\n-\t\tv.name = req.NewName\n-\tcase *Link:\n-\t\tv.name = req.NewName\n-\t}\n-\n-\terr = d.fs.inodestore.Move(in, newDir.(*DirNode).inode, req.NewName)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\treturn nil\n-}\n-\n-var _ fs.NodeSymlinker = (*DirNode)(nil)\n-\n-func (d *DirNode) Symlink(ctx context.Context, req *fuse.SymlinkRequest) (fs.Node, error) {\n-\tstore, _, err := d.fs.StoreForInodeAndName(d.inode, req.NewName)\n-\tif err != nil && errors.Is(err, inode.NotFoundErr) {\n-\t\treturn nil, fuse.ENOENT\n-\t}\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"failed to get store for dir: %w\", err)\n-\t}\n-\n-\tdirFullName, err := d.fs.FullName(d.inode)\n-\tif err != nil && errors.Is(err, inode.NotFoundErr) {\n-\t\treturn nil, fuse.ENOENT\n-\t}\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"failed to get full name for dir: %w\", err)\n-\t}\n-\n-\terr = store.CreateLink(\n-\t\tdirFullName,\n-\t\treq.NewName,\n-\t\treq.Target,\n-\t)\n-\tif err != nil {\n-\t\tlog.Println(err)\n-\t\treturn nil, err\n-\t}\n-\n-\tn := &Link{\n-\t\ttarget: req.Target,\n-\t\tname:   req.NewName,\n-\t\tfs:     d.fs,\n-\t}\n-\tchildInode, err := d.fs.inodestore.Add(d.inode, req.NewName, n)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tn.inode = childInode\n-\n-\treturn n, nil\n-}\n-\n-func (d *DirNode) InvalidateCache() {\n-\td.hasListedChildrenFromRemote = false\n-\td.forceReadChildrenFromRemote = true\n-}\n",
    "diff --git a/client/fuse-client/fuse/file.go b/client/fuse-client/fuse/file.go\ndeleted file mode 100644\nindex 50a5923..0000000\n--- a/client/fuse-client/fuse/file.go\n+++ /dev/null\n@@ -1,196 +0,0 @@\n-package fuse\n-\n-import (\n-\t\"context\"\n-\t\"errors\"\n-\t\"fmt\"\n-\t\"log\"\n-\tfileproto \"mash/api/files\"\n-\t\"mash/client/fuse-client/inode\"\n-\tmashfuse \"mash/client/fuse-client/workspace\"\n-\t\"os\"\n-\t\"path\"\n-\t\"time\"\n-\n-\t\"bazil.org/fuse\"\n-\t\"bazil.org/fuse/fs\"\n-\t\"bazil.org/fuse/fuseutil\"\n-)\n-\n-type DataNode struct {\n-\tinode   uint64\n-\tname    string\n-\tfs      *FS\n-\tstat    *fileproto.FileStat\n-\thasData bool\n-\tdata    []byte\n-}\n-\n-var _ fs.HandleReader = (*DataNode)(nil)\n-\n-func (n *DataNode) Read(ctx context.Context, req *fuse.ReadRequest, resp *fuse.ReadResponse) error {\n-\t// TODO: Support a partial-read API?\n-\n-\tif !n.hasData {\n-\t\tallData, err := n.ReadAll(ctx)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tn.data = allData\n-\t\tn.hasData = true\n-\t}\n-\n-\tfuseutil.HandleRead(req, resp, n.data)\n-\n-\treturn nil\n-}\n-\n-var _ fs.HandleReadAller = (*DataNode)(nil)\n-\n-func (n *DataNode) ReadAll(ctx context.Context) ([]byte, error) {\n-\tstore, fileFullName, err := n.storeAndFullPath()\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tdir, name := path.Split(fileFullName)\n-\tfile, err := store.ReadFile(dir, name)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tn.stat = file.Stat\n-\treturn file.Data, nil\n-}\n-\n-var _ fs.HandleWriter = (*DataNode)(nil)\n-\n-func (n *DataNode) Write(ctx context.Context, req *fuse.WriteRequest, resp *fuse.WriteResponse) error {\n-\tstore, fileFullName, err := n.storeAndFullPath()\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\tdir, name := path.Split(fileFullName)\n-\n-\tsize, err := store.WriteFile(dir, name, req.Data, uint64(req.Offset))\n-\tif err != nil {\n-\t\tlog.Println(\"write error:\", err)\n-\t\treturn nil\n-\t}\n-\n-\t// Update size if we have it\n-\tif n.stat != nil {\n-\t\tn.stat.Size = size\n-\t\tn.stat.ModTime = uint64(time.Now().Second())\n-\t}\n-\n-\t// Mark as invalidated\n-\tn.fs.invalidations <- n.inode\n-\n-\tresp.Size = len(req.Data)\n-\treturn nil\n-}\n-\n-var _ fs.NodeSetattrer = (*DataNode)(nil)\n-\n-// Setattr is platform specific\n-// Setattr can be called to shrink files\n-func (n *DataNode) Setattr(ctx context.Context, req *fuse.SetattrRequest, resp *fuse.SetattrResponse) error {\n-\tstore, fileFullName, err := n.storeAndFullPath()\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\tdir, name := path.Split(fileFullName)\n-\n-\t// Setattr can be called for other reasons, where req.Size will be 0\n-\tif req.Valid.Size() {\n-\t\terr := store.SetFileSize(dir, name, req.Size)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\n-\t\tif n.stat != nil {\n-\t\t\tn.stat.Size = req.Size\n-\t\t}\n-\t}\n-\n-\t// Update file mode\n-\tif req.Valid.Mode() {\n-\t\terr := store.SetFileMode(dir, name, req.Mode)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\n-\t// Mark as invalidated\n-\tn.fs.invalidations <- n.inode\n-\n-\treturn nil\n-}\n-\n-func (n DataNode) Attr(ctx context.Context, a *fuse.Attr) error {\n-\tif n.fs.config.Debug {\n-\t\tlog.Printf(\"Attr: inode=%d name=%s\", n.inode, n.name)\n-\t}\n-\n-\tif n.stat == nil {\n-\t\tstore, fileFullName, err := n.storeAndFullPath()\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tdir, name := path.Split(fileFullName)\n-\t\tattr, err := store.GetFileAttr(dir, name)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tn.stat = attr\n-\t}\n-\n-\ta.Size = n.stat.Size\n-\ta.Mode = os.FileMode(n.stat.Mode)\n-\ta.Mtime = time.Unix(int64(n.stat.ModTime), 0)\n-\n-\ta.Inode = n.inode\n-\ta.Uid = uint32(os.Getuid())\n-\ta.Gid = uint32(os.Getgid())\n-\n-\ta.Valid = time.Second * 60\n-\n-\treturn nil\n-}\n-\n-var _ fs.NodeFsyncer = (*DataNode)(nil)\n-\n-func (n DataNode) Fsync(ctx context.Context, req *fuse.FsyncRequest) error {\n-\t// All writes are fsynced by default\n-\t// Implement this interface to report fsync-like guarantees\n-\treturn nil\n-}\n-\n-func (n *DataNode) InvalidateCache() {\n-\tn.hasData = false\n-\tn.stat = nil\n-\tn.data = nil\n-}\n-\n-func (n *DataNode) storeAndFullPath() (mashfuse.WorkspaceReadWriter, string, error) {\n-\tstore, _, err := n.fs.StoreForInode(n.inode)\n-\tif err != nil && errors.Is(err, inode.NotFoundErr) {\n-\t\treturn nil, \"\", fuse.ENOENT\n-\t}\n-\tif err != nil {\n-\t\treturn nil, \"\", fmt.Errorf(\"failed to get store for file: %w\", err)\n-\t}\n-\n-\tfileFullName, err := n.fs.FullName(n.inode)\n-\tif err != nil && errors.Is(err, inode.NotFoundErr) {\n-\t\treturn nil, \"\", fuse.ENOENT\n-\t}\n-\tif err != nil {\n-\t\treturn nil, \"\", fmt.Errorf(\"failed to get full name for file: %w\", err)\n-\t}\n-\n-\treturn store, fileFullName, nil\n-}\n",
    "diff --git a/client/fuse-client/fuse/fuse.go b/client/fuse-client/fuse/fuse.go\ndeleted file mode 100644\nindex e205581..0000000\n--- a/client/fuse-client/fuse/fuse.go\n+++ /dev/null\n@@ -1,319 +0,0 @@\n-package fuse\n-\n-import (\n-\t\"context\"\n-\t\"errors\"\n-\t\"fmt\"\n-\tignore \"github.com/sabhiram/go-gitignore\"\n-\t\"log\"\n-\t\"mash/client/fuse-client/pkg/api\"\n-\t\"os\"\n-\t\"path\"\n-\t\"sync\"\n-\t\"time\"\n-\n-\t\"mash/client/fuse-client/inode\"\n-\tmashfuse \"mash/client/fuse-client/workspace\"\n-\n-\t\"bazil.org/fuse\"\n-\t\"bazil.org/fuse/fs\"\n-\t_ \"bazil.org/fuse/fs/fstestutil\"\n-)\n-\n-type Config struct {\n-\tMountpoint string\n-\tViewID     string\n-\tAPIHost    string\n-\tAuthToken  string\n-\n-\tDebugFuse bool\n-\tDebug     bool\n-\n-\t// injected for testing\n-\tinvalidationChannel chan uint64\n-}\n-\n-type ChangeEvent interface {\n-\tChangeEvent() bool\n-}\n-\n-// Dummy type to restrict what can implement ChangeEvent\n-type ChangeEventBase struct{}\n-\n-func (ChangeEventBase) ChangeEvent() bool {\n-\treturn true\n-}\n-\n-type ChangeWorkspaceEvent struct {\n-\tChangeEventBase\n-\tNewWorkspaceID string\n-}\n-\n-func Run(config Config, api api.SturdyAPI, remoteStore, localStore mashfuse.WorkspaceReadWriter, wg *sync.WaitGroup) error {\n-\terr := fuse.Unmount(config.Mountpoint)\n-\tlog.Println(\"Unmount: \", err)\n-\n-\tview, err := api.GetView(config.ViewID)\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"failed to get info: %w\", err)\n-\t}\n-\tcodebase, err := api.GetCodebase(view.CodebaseID)\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"failed to get info: %w\", err)\n-\t}\n-\n-\tvar maxSeenRevision = view.Revision\n-\n-\tc, err := fuse.Mount(\n-\t\tconfig.Mountpoint,\n-\t\tfuse.FSName(\"sturdy\"),\n-\t\tfuse.Subtype(\"sturdy\"),\n-\t\tfuse.NoAppleDouble(),\n-\t\tfuse.LocalVolume(), // Make it appear as a Volume in Finder.\n-\t\tfuse.AsyncRead(),\n-\t\tfuse.VolumeName(fmt.Sprintf(\"Sturdy - %s\", codebase.Name)),\n-\t)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tdefer c.Close()\n-\n-\tif p := c.Protocol(); !p.HasInvalidate() {\n-\t\treturn fmt.Errorf(\"kernel FUSE support is too old to have invalidations: version %v\", p)\n-\t}\n-\n-\tsrv := fs.New(c, &fs.Config{\n-\t\tDebug: func(msg interface{}) {\n-\t\t\tif config.DebugFuse {\n-\t\t\t\tlog.Printf(\"fuse debug: %+v\", msg)\n-\t\t\t}\n-\t\t},\n-\t})\n-\n-\tlog.Printf(\"config: %+v\", config)\n-\n-\tgitignore, err := ignore.CompileIgnoreLines(\n-\t\t\"node_modules\",\n-\t)\n-\tif err != nil {\n-\t\tpanic(err)\n-\t}\n-\n-\t// Create invalidation channel if not set\n-\tif config.invalidationChannel == nil {\n-\t\tconfig.invalidationChannel = make(chan uint64, 1024) // Buffer up to 1024 invalidations\n-\t}\n-\n-\tfilesys := &FS{\n-\t\tinodestore:    inode.NewInodeStore(),\n-\t\tremoteStore:   remoteStore,\n-\t\tlocalStore:    localStore,\n-\t\tconfig:        config,\n-\t\tgitignore:     gitignore,\n-\t\tinvalidations: config.invalidationChannel,\n-\t}\n-\terr = filesys.Prepare()\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"failed to create fs: %w\", err)\n-\t}\n-\n-\t// Report to parent that we've successfully mounted the view\n-\tlog.Printf(\"[STATUS] %s is ready\", config.Mountpoint)\n-\twg.Done()\n-\n-\tgo func() {\n-\t\tfor nodeID := range filesys.invalidations {\n-\t\t\tfilesys.RecursiveInodeInvalidation(c, nodeID)\n-\t\t}\n-\t}()\n-\n-\tgo func() {\n-\t\tfor {\n-\t\t\ttime.Sleep(time.Second * 5)\n-\n-\t\t\tpollView, err := api.GetView(view.ID)\n-\t\t\tif err != nil {\n-\t\t\t\tlog.Printf(\"failed to poll view: %v\", err)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\n-\t\t\t// Invalidate the root node\n-\t\t\tif pollView.Revision > maxSeenRevision {\n-\t\t\t\tlog.Println(\"Remote is on a newer revision, invalidating root\")\n-\t\t\t\tfilesys.invalidations <- 0\n-\t\t\t\tmaxSeenRevision = pollView.Revision\n-\t\t\t}\n-\t\t}\n-\t}()\n-\n-\t// Start fuse\n-\tif err := srv.Serve(filesys); err != nil {\n-\t\treturn err\n-\t}\n-\n-\t// Check if the mount process has an error to report.\n-\t<-c.Ready\n-\tif err := c.MountError; err != nil {\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-\n-type FS struct {\n-\t// inodes inode.ReadWriter\n-\tremoteStore mashfuse.WorkspaceReadWriter\n-\tlocalStore  mashfuse.WorkspaceReadWriter\n-\tinodestore  *inode.Store\n-\tconfig      Config\n-\tgitignore   *ignore.GitIgnore\n-\n-\tinvalidations chan uint64 // inodes to invalidate\n-\n-\troot *DirNode\n-}\n-\n-var _ fs.FS = (*FS)(nil)\n-\n-func (f *FS) Prepare() error {\n-\tf.root = &DirNode{\n-\t\tfs:    f,\n-\t\tname:  \"/\", // TODO?\n-\t\tinode: 0,\n-\t\tmode:  os.ModeDir | 0755, // drwxr-xr-x\n-\t}\n-\n-\tf.inodestore.AddRoot(f.root)\n-\n-\treturn nil\n-}\n-\n-func (f *FS) Root() (fs.Node, error) {\n-\treturn f.root, nil\n-}\n-\n-var _ fs.FSStatfser = (*FS)(nil)\n-\n-func (f *FS) Statfs(ctx context.Context, req *fuse.StatfsRequest, resp *fuse.StatfsResponse) error {\n-\t// Report as 256 GB available\n-\tresp.Blocks = 1000000000 // Total data blocks in file system.\n-\tresp.Bfree = 1000000000  // Free blocks in file system.\n-\tresp.Bavail = 1000000000 // Free blocks in file system if you're not root.\n-\tresp.Files = 0           // Total files in file system.\n-\tresp.Ffree = 1000        // Free files in file system.\n-\tresp.Bsize = 2048        // Block size\n-\tresp.Namelen = 256       // Maximum file name length?\n-\tresp.Frsize = 256        // Fragment size, smallest addressable data size in the file system.\n-\treturn nil\n-}\n-\n-func (f *FS) FullName(inode uint64) (string, error) {\n-\tvar parts []string\n-\n-\tfor {\n-\t\tnode, err := f.inodestore.Get(inode)\n-\t\tif err != nil {\n-\t\t\treturn \"\", err\n-\t\t}\n-\n-\t\tparts = append(parts, node.Name)\n-\t\tinode = node.Parent\n-\n-\t\tif inode == 0 {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\n-\treverse(parts)\n-\n-\treturn path.Join(parts...), nil\n-}\n-\n-func reverse(a []string) {\n-\tfor i := len(a)/2 - 1; i >= 0; i-- {\n-\t\topp := len(a) - 1 - i\n-\t\ta[i], a[opp] = a[opp], a[i]\n-\t}\n-}\n-\n-func (f *FS) StoreForInode(inode uint64) (ws mashfuse.WorkspaceReadWriter, isRemote bool, err error) {\n-\tp, err := f.FullName(inode)\n-\tif err != nil {\n-\t\treturn nil, false, err\n-\t}\n-\n-\tn, err := f.inodestore.Get(inode)\n-\tif err != nil {\n-\t\treturn nil, false, err\n-\t}\n-\n-\t// Matches as full path\n-\tif f.gitignore.MatchesPath(p) {\n-\t\treturn f.localStore, false, nil\n-\t}\n-\t// Matches as file name\n-\tif f.gitignore.MatchesPath(n.Name) {\n-\t\treturn f.localStore, false, nil\n-\t}\n-\n-\treturn f.remoteStore, true, nil\n-}\n-\n-func (f *FS) StoreForInodeAndName(inode uint64, name string) (ws mashfuse.WorkspaceReadWriter, isRemote bool, err error) {\n-\tp, err := f.FullName(inode)\n-\tif err != nil {\n-\t\treturn nil, false, err\n-\t}\n-\n-\t// Matches as full path\n-\tif f.gitignore.MatchesPath(p) {\n-\t\treturn f.localStore, false, nil\n-\t}\n-\t// Matches as file name\n-\tif f.gitignore.MatchesPath(name) {\n-\t\treturn f.localStore, false, nil\n-\t}\n-\n-\treturn f.remoteStore, true, nil\n-}\n-\n-type CacheInvalidator interface {\n-\tInvalidateCache()\n-}\n-\n-func (fs *FS) RecursiveInodeInvalidation(conn *fuse.Conn, nodeID uint64) {\n-\tif fs.config.Debug {\n-\t\tlog.Printf(\"invalidating: %d\", nodeID)\n-\t}\n-\n-\tnode, err := fs.inodestore.Get(nodeID)\n-\tif err != nil {\n-\t\tlog.Println(err)\n-\t\treturn\n-\t}\n-\n-\tif ci, ok := node.FuseNode.(CacheInvalidator); ok {\n-\t\tci.InvalidateCache()\n-\t} else {\n-\t\tlog.Printf(\"did not implement cache invalidator t=%T\", node.FuseNode)\n-\t}\n-\n-\terr = conn.InvalidateNode(fuse.NodeID(nodeID), 0, -1)\n-\tif err != nil && !errors.Is(err, fuse.ErrNotCached) {\n-\t\tlog.Printf(\"failed to invalidate node: %v\", err)\n-\t\treturn\n-\t}\n-\n-\t// Invalidate children\n-\tchildren, err := fs.inodestore.GetChildren(nodeID)\n-\tif err != nil {\n-\t\tif errors.Is(err, inode.ParentDoesNotHaveChildrenErr) {\n-\t\t\treturn\n-\t\t}\n-\t\tlog.Printf(\"failed to get children to invalidate: %v\", err)\n-\t\treturn\n-\t}\n-\n-\tfor _, id := range children {\n-\t\tfs.RecursiveInodeInvalidation(conn, id)\n-\t}\n-}\n",
    "diff --git a/client/fuse-client/fuse/fuse_test.go b/client/fuse-client/fuse/fuse_test.go\ndeleted file mode 100644\nindex ae0667c..0000000\n--- a/client/fuse-client/fuse/fuse_test.go\n+++ /dev/null\n@@ -1,177 +0,0 @@\n-package fuse\n-\n-import (\n-\t\"github.com/stretchr/testify/assert\"\n-\t\"io/ioutil\"\n-\t\"mash/client/fuse-client/local\"\n-\t\"mash/client/fuse-client/pkg/api\"\n-\t\"os\"\n-\t\"path\"\n-\t\"sort\"\n-\t\"sync\"\n-\t\"testing\"\n-)\n-\n-type dummyApiClient struct {\n-\trevision int32\n-}\n-\n-func (d *dummyApiClient) GetView(id string) (api.View, error) {\n-\treturn api.View{\n-\t\tRevision: d.revision,\n-\t}, nil\n-}\n-\n-func (dummyApiClient) GetCodebase(id string) (api.Codebase, error) {\n-\treturn api.Codebase{}, nil\n-}\n-\n-func TestFuseLocal(t *testing.T) {\n-\tt.SkipNow()\n-\n-\tremotesPath, err := ioutil.TempDir(\"\", \"mash-remote\")\n-\tassert.NoError(t, err)\n-\n-\tmountPath, err := ioutil.TempDir(\"\", \"mash-mount\")\n-\tassert.NoError(t, err)\n-\n-\t// Start two local remotes\n-\t// One as local and one as a fake \"grpc\" client\n-\tremotePath := remotesPath + \"/remote-remote\"\n-\tremoteLocalStore := local.NewLocalReadWriter(remotePath)\n-\tlocalLocalStore := local.NewLocalReadWriter(remotesPath + \"/local-remote\")\n-\n-\tvar wg sync.WaitGroup\n-\twg.Add(1)\n-\n-\tapi := &dummyApiClient{0}\n-\n-\tinvalidations := make(chan uint64)\n-\n-\tgo func() {\n-\t\terr = Run(\n-\t\t\tConfig{\n-\t\t\t\tMountpoint:          mountPath,\n-\t\t\t\tinvalidationChannel: invalidations,\n-\t\t\t\tDebugFuse:           true,\n-\t\t\t\tDebug:               true,\n-\t\t\t},\n-\t\t\tapi,\n-\t\t\tremoteLocalStore,\n-\t\t\tlocalLocalStore,\n-\t\t\t&wg,\n-\t\t)\n-\t\tassert.NoError(t, err)\n-\t\tif err != nil {\n-\t\t\tt.FailNow()\n-\t\t}\n-\t}()\n-\n-\twg.Wait()\n-\n-\t// Do some test\n-\terr = ioutil.WriteFile(path.Join(mountPath, \"hey.txt\"), []byte(\"hello world\"), 0666)\n-\tassert.NoError(t, err)\n-\n-\tcontents, err := ioutil.ReadFile(path.Join(mountPath, \"hey.txt\"))\n-\tassert.NoError(t, err)\n-\tassert.Equal(t, \"hello world\", string(contents))\n-\n-\tfinfo, err := os.Stat(path.Join(mountPath, \"hey.txt\"))\n-\tassert.NoError(t, err)\n-\tassert.Equal(t, os.FileMode(0644), finfo.Mode().Perm()) // TODO: Why is this not 0666?\n-\tassert.Equal(t, int64(11), finfo.Size())\n-\n-\terr = ioutil.WriteFile(path.Join(mountPath, \"hey2.txt\"), []byte(\"hello world\\na second time\"), 0666)\n-\tassert.NoError(t, err)\n-\n-\tfilesInDir, err := ioutil.ReadDir(mountPath)\n-\tassert.NoError(t, err)\n-\tassert.Len(t, filesInDir, 2)\n-\n-\tassert.FileExists(t, path.Join(mountPath, \"hey.txt\"))\n-\tassert.FileExists(t, path.Join(mountPath, \"hey2.txt\"))\n-\tassertFilesInDir(t, mountPath, []string{\"hey.txt\", \"hey2.txt\"})\n-\n-\terr = os.Rename(path.Join(mountPath, \"hey2.txt\"), path.Join(mountPath, \"renamed-hey2.txt\"))\n-\tassert.NoError(t, err)\n-\tassert.FileExists(t, path.Join(mountPath, \"hey.txt\"))\n-\tassert.NoFileExists(t, path.Join(mountPath, \"hey2.txt\"))\n-\tassert.FileExists(t, path.Join(mountPath, \"renamed-hey2.txt\"))\n-\tassertFilesInDir(t, mountPath, []string{\"hey.txt\", \"renamed-hey2.txt\"})\n-\n-\t// Modify contents on the remote, and invalidate the caches\n-\terr = ioutil.WriteFile(path.Join(remotePath, \"hey-written-remotely.txt\"), []byte(\"on\\nthe\\nremote\\n\"), 0666)\n-\tassert.NoError(t, err)\n-\n-\t// Read dir via fuse (should fail)\n-\tassert.NoFileExists(t, path.Join(mountPath, \"hey-written-remotely.txt\"))\n-\n-\t// Trigger invalidation of root\n-\tinvalidations <- 0\n-\n-\t// File should now be accessable\n-\tassert.FileExists(t, path.Join(mountPath, \"hey-written-remotely.txt\"))\n-\tassertContents(t, path.Join(mountPath, \"hey-written-remotely.txt\"), \"on\\nthe\\nremote\\n\")\n-\n-\tassertFilesInDir(t, mountPath, []string{\"hey.txt\", \"renamed-hey2.txt\", \"hey-written-remotely.txt\"})\n-\n-\t// Update the content remotely\n-\terr = ioutil.WriteFile(path.Join(remotePath, \"hey-written-remotely.txt\"), []byte(\"on\\n~~~~the~~~~\\nremote\\n\"), 0666)\n-\tassert.NoError(t, err)\n-\n-\tfiles, err := ioutil.ReadDir(mountPath)\n-\tassert.NoError(t, err)\n-\tt.Logf(\"files: %+v\", files)\n-\tfor _, f := range files {\n-\t\tt.Logf(\"f: %+v\", f)\n-\t}\n-\n-\tassert.FileExists(t, path.Join(mountPath, \"hey-written-remotely.txt\"))\n-\tassertContents(t, path.Join(mountPath, \"hey-written-remotely.txt\"), \"on\\nthe\\nremote\\n\")\n-\n-\t// Trigger invalidation of root\n-\tinvalidations <- 0\n-\n-\tassertContents(t, path.Join(mountPath, \"hey-written-remotely.txt\"), \"on\\n~~~~the~~~~\\nremote\\n\")\n-\n-\t// Remove a file remotely, it should disappear\n-\terr = os.Remove(path.Join(remotePath, \"hey-written-remotely.txt\"))\n-\tassert.NoError(t, err)\n-\n-\tassert.FileExists(t, path.Join(mountPath, \"hey-written-remotely.txt\"))\n-\n-\t// Trigger invalidation of root\n-\tinvalidations <- 0\n-\n-\t// TODO: Also handle invalidations when read happens before list???\n-\tassertFilesInDir(t, mountPath, []string{\"hey.txt\", \"renamed-hey2.txt\"})\n-\n-\tassert.NoFileExists(t, path.Join(mountPath, \"hey-written-remotely.txt\"))\n-\n-\tdata, err := ioutil.ReadFile(path.Join(mountPath, \"hey-written-remotely.txt\"))\n-\tt.Logf(\"err=%v data=%s\", err, string(data))\n-}\n-\n-func assertContents(t *testing.T, path string, expected string) {\n-\tcontents, err := ioutil.ReadFile(path)\n-\tif assert.NoError(t, err) {\n-\t\tassert.Equal(t, expected, string(contents))\n-\t}\n-}\n-\n-func assertFilesInDir(t *testing.T, dir string, expected []string) {\n-\n-\tfiles, err := ioutil.ReadDir(dir)\n-\tif assert.NoError(t, err) {\n-\t\tvar names []string\n-\t\tfor _, f := range files {\n-\t\t\tnames = append(names, f.Name())\n-\t\t}\n-\n-\t\tsort.Strings(expected)\n-\t\tsort.Strings(names)\n-\n-\t\tassert.Equal(t, expected, names)\n-\t}\n-}\n",
    "diff --git a/client/fuse-client/fuse/link.go b/client/fuse-client/fuse/link.go\ndeleted file mode 100644\nindex 3a3e19e..0000000\n--- a/client/fuse-client/fuse/link.go\n+++ /dev/null\n@@ -1,33 +0,0 @@\n-package fuse\n-\n-import (\n-\t\"context\"\n-\t\"os\"\n-\n-\t\"bazil.org/fuse\"\n-\t\"bazil.org/fuse/fs\"\n-)\n-\n-type Link struct {\n-\ttarget string\n-\t// dir    *DirNode\n-\tname   string\n-\tinode  uint64\n-\tfs     *FS\n-}\n-\n-var _ fs.Node = (*Link)(nil)\n-\n-func (d *Link) Attr(ctx context.Context, a *fuse.Attr) error {\n-\ta.Inode = d.inode // is generated automatically if set to 0\n-\ta.Mode = os.ModeSymlink\n-\ta.Uid = uint32(os.Getuid())\n-\ta.Gid = uint32(os.Getgid())\n-\treturn nil\n-}\n-\n-var _ fs.NodeReadlinker = (*Link)(nil)\n-\n-func (d *Link) Readlink(ctx context.Context, req *fuse.ReadlinkRequest) (string, error) {\n-\treturn d.target, nil\n-}\n",
    "diff --git a/client/fuse-client/grpc/grpc.go b/client/fuse-client/grpc/grpc.go\ndeleted file mode 100644\nindex 29877a0..0000000\n--- a/client/fuse-client/grpc/grpc.go\n+++ /dev/null\n@@ -1,209 +0,0 @@\n-package grpc\n-\n-import (\n-\t\"context\"\n-\t\"github.com/google/uuid\"\n-\t\"google.golang.org/grpc\"\n-\tfilesproto \"mash/api/files\"\n-\tproto \"mash/api/filesystem\"\n-\t\"os\"\n-)\n-\n-type grpcClient struct {\n-\tviewID uuid.UUID\n-\tclient proto.FileSystemClient\n-}\n-\n-func NewGrpcClient(viewID uuid.UUID, client proto.FileSystemClient) *grpcClient {\n-\treturn &grpcClient{\n-\t\tviewID: viewID,\n-\t\tclient: client,\n-\t}\n-}\n-\n-func (g *grpcClient) ReadFile(dir, name string) (*filesproto.File, error) {\n-\tresp, err := g.client.ReadFile(\n-\t\tcontext.Background(),\n-\t\t&proto.ReadFileRequest{\n-\t\t\tViewId: g.viewID.String(),\n-\t\t\tDir:    dir,\n-\t\t\tName:   name,\n-\t\t},\n-\n-\t\tgrpc.MaxCallRecvMsgSize(100000000), // 100MB\n-\t\tgrpc.MaxCallSendMsgSize(100000000), // 100MB\n-\t)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn resp, nil\n-}\n-func (g *grpcClient) ListDir(dir string) ([]*filesproto.File, error) {\n-\tresp, err := g.client.ListDir(\n-\t\tcontext.Background(),\n-\t\t&proto.ListDirRequest{\n-\t\t\tViewId: g.viewID.String(),\n-\t\t\tDir:    dir,\n-\t\t},\n-\t)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\treturn resp.Files, nil\n-}\n-\n-func (g *grpcClient) WriteFile(dir, name string, data []byte, offset uint64) (uint64, error) {\n-\tresp, err := g.client.WriteFile(\n-\t\tcontext.Background(),\n-\t\t&proto.WriteFileRequest{\n-\t\t\tViewId: g.viewID.String(),\n-\t\t\tDir:    dir,\n-\t\t\tName:   name,\n-\t\t\tData:   data,\n-\t\t\tOffset: offset,\n-\t\t},\n-\t\tgrpc.MaxCallRecvMsgSize(100000000), // 100MB\n-\t\tgrpc.MaxCallSendMsgSize(100000000), // 100MB\n-\t)\n-\tif err != nil {\n-\t\treturn 0, err\n-\t}\n-\treturn resp.Size, nil\n-}\n-\n-func (g *grpcClient) CreateFile(dir, name string, mode os.FileMode) error {\n-\t_, err := g.client.CreateFile(\n-\t\tcontext.Background(),\n-\t\t&proto.CreateFileRequest{\n-\t\t\tViewId: g.viewID.String(),\n-\t\t\tDir:    dir,\n-\t\t\tName:   name,\n-\t\t\tMode:   uint32(mode),\n-\t\t},\n-\t)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-\n-func (g *grpcClient) SetFileMode(dir, name string, mode os.FileMode) error {\n-\t_, err := g.client.SetFileMode(\n-\t\tcontext.Background(),\n-\t\t&proto.SetFileModeRequest{\n-\t\t\tViewId: g.viewID.String(),\n-\t\t\tDir:    dir,\n-\t\t\tName:   name,\n-\t\t\tMode:   uint32(mode.Perm()),\n-\t\t},\n-\t)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-\n-func (g *grpcClient) SetFileSize(dir, name string, size uint64) error {\n-\t_, err := g.client.SetFileSize(\n-\t\tcontext.Background(),\n-\t\t&proto.SetFileSizeRequest{\n-\t\t\tViewId: g.viewID.String(),\n-\t\t\tDir:    dir,\n-\t\t\tName:   name,\n-\t\t\tSize:   size,\n-\t\t},\n-\t)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-\n-func (g *grpcClient) DeleteFile(dir, name string) error {\n-\t_, err := g.client.DeleteFile(\n-\t\tcontext.Background(),\n-\t\t&proto.DeleteFileRequest{\n-\t\t\tViewId: g.viewID.String(),\n-\t\t\tDir:    dir,\n-\t\t\tName:   name,\n-\t\t},\n-\t)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-func (g *grpcClient) Rename(oldDir, oldName, newDir, newName string) error {\n-\t_, err := g.client.RenameFile(\n-\t\tcontext.Background(),\n-\t\t&proto.RenameFileRequest{\n-\t\t\tViewId:  g.viewID.String(),\n-\t\t\tDir:     oldDir,\n-\t\t\tName:    oldName,\n-\t\t\tNewDir:  newDir,\n-\t\t\tNewName: newName,\n-\t\t},\n-\t)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-func (g *grpcClient) CreateDir(dir, name string, mode os.FileMode) error {\n-\t_, err := g.client.CreateDir(\n-\t\tcontext.Background(),\n-\t\t&proto.CreateDirRequest{\n-\t\t\tViewId: g.viewID.String(),\n-\t\t\tDir:    dir,\n-\t\t\tName:   name,\n-\t\t\tMode:   uint32(mode.Perm()),\n-\t\t},\n-\t)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-\n-func (g *grpcClient) DeleteDir(dir, name string) error {\n-\t_, err := g.client.DeleteDir(\n-\t\tcontext.Background(),\n-\t\t&proto.DeleteDirRequest{\n-\t\t\tViewId: g.viewID.String(),\n-\t\t\tDir:    dir,\n-\t\t\tName:   name,\n-\t\t},\n-\t)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-\n-func (g *grpcClient) CreateLink(dir string, name string, target string) error {\n-\t_, err := g.client.CreateLink(\n-\t\tcontext.Background(),\n-\t\t&proto.CreateLinkRequest{\n-\t\t\tViewId: g.viewID.String(),\n-\t\t\tDir:    dir,\n-\t\t\tName:   name,\n-\t\t\tTarget: target,\n-\t\t},\n-\t)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-\n-func (g *grpcClient) GetFileAttr(dir string, name string) (*filesproto.FileStat, error) {\n-\treturn g.client.GetFileAttr(\n-\t\tcontext.Background(),\n-\t\t&proto.GetFileAttrRequest{\n-\t\t\tViewId: g.viewID.String(),\n-\t\t\tDir:    dir,\n-\t\t\tName:   name,\n-\t\t},\n-\t)\n-}\n",
    "diff --git a/client/fuse-client/hack/fs-test.sh b/client/fuse-client/hack/fs-test.sh\ndeleted file mode 100644\nindex 73736af..0000000\n--- a/client/fuse-client/hack/fs-test.sh\n+++ /dev/null\n@@ -1,143 +0,0 @@\n-#!/bin/bash\n-\n-# fs-test.sh runs a few normal file system operations and asserts the expected behaviour\n-# If any step fails, the program will exit\n-\n-set -euo pipefail\n-set -x\n-\n-TestNodeModulesInSubdir() {\n-  rm -rf somesubdir || true\n-  mkdir somesubdir\n-  mkdir somesubdir/node_modules\n-  echo \"what\" > somesubdir/node_modules/whatski\n-  rm -rf somesubdir || true\n-}\n-\n-TestNodeModulesInSubdir\n-\n-runTests() {\n-  # Cleanup\n-  echo \"~~~ Cleanup\"\n-  rm world.txt aaa sym target.txt oldname || true;\n-  rm -rf ddiirr aa foo web || true\n-\n-  # Test root\n-  echo \"~~~ Test Root\"\n-  ls -la | grep -v \"total\" | wc -l | grep \"2\" # has only two items (. and ..)\n-  ls -la | grep -E \" \\.$\" # has . dir\n-  ls -la | grep -E \" \\.\\.$\" # has .. dir\n-\n-  # Write to file\n-  echo \"~~~ Write To File\"\n-  echo \"hello\" > world.txt\n-  # ls -lah world.txt | grep \"\\-rw-r--r--\"\n-  ls -la world.txt | awk '{print $5}' | grep \"6\"\n-  grep \"hello\" world.txt\n-\n-  # Append to file\n-  echo \"~~~ Append To File\"\n-  echo \"secondrow\" >> world.txt\n-  ls -la world.txt | awk '{print $5}' | grep \"16\"\n-  grep \"hello\" world.txt\n-  grep \"secondrow\" world.txt\n-\n-  # Create symlink\n-  echo \"~~~ Create Symlink\"\n-  echo \"abc\" > target.txt\n-  ln -s target.txt sym\n-  grep \"abc\" sym\n-\n-  # Truncate file\n-  # TODO: Linux only?\n-  # echo \"abc\" >> byebye.txt;\n-  # truncate -s 0 byebye.txt;\n-  # wc -l byebye.txt | grep \"0 byebye\\.txt\"\n-\n-  # Create directory\n-  echo \"~~~ Create Directory\"\n-  mkdir ddiirr\n-  ls -lah | grep ddiirr | grep \"drwxr-xr-x\"\n-  ls -lah ddiirr/ | wc -l  | grep 3\n-\n-  # Write to file in dir\n-  echo \"~~~ Write to file in dir\"\n-  echo \"in-dir\" > ddiirr/yay\n-  grep \"in-dir\" ddiirr/yay\n-  ls -la ddiirr/ | grep \"yay\" | awk '{print $5}' | grep \"7\"\n-\n-  # Remove file\n-  echo \"~~~ Remove file\"\n-  ls -lah ddiirr/ | wc -l | grep 4\n-  rm ddiirr/yay\n-  ls -lah ddiirr/ | wc -l | grep 3\n-\n-  # Remove dir\n-  echo \"~~~ Remove dir\"\n-  echo \"1\" > ddiirr/first\n-  echo \"2\" > ddiirr/second\n-  ls -lah | grep -v total | wc -l | grep 6\n-  rm -rf ddiirr\n-  ls -lah | grep -v total | wc -l | grep 5\n-\n-  # Dir and file with same prefix (aaa should not be included in listing of aa)\n-  echo \"~~~ Dir and file with same prefix\"\n-  mkdir aa\n-  echo \"hey\" > aaa\n-  ls -lah aa | wc -l | grep \"3\"\n-\n-  # Rename files\n-  echo \"~~~ Rename files\"\n-  echo \"foobar-123\" > oldname\n-  mv oldname newname\n-  grep \"foobar-123\" newname\n-  ls -lah | grep name | wc -l | grep 1\n-  rm newname\n-\n-  # Rename dirs\n-  echo \"~~~ Rename dirs\"\n-  mkdir -p foo/bar/baz/dir-to-move/dir-in-moved-dir/a\n-  mkdir -p foo/bar/baz/dir-to-move/dir-in-moved-dir/b\n-  echo \"file-in-moved-dir\" > foo/bar/baz/dir-to-move/file-in-moved-dir-1\n-  echo \"file-in-moved-dir\" > foo/bar/baz/dir-to-move/file-in-moved-dir-2\n-  echo \"file-in-moved-dir\" > foo/bar/baz/dir-to-move/dir-in-moved-dir/a/in-a\n-  echo \"file-in-moved-dir\" > foo/bar/baz/dir-to-move/dir-in-moved-dir/b/in-b\n-  ls -lah foo/bar/baz | wc -l | grep 4 # total / . / ... / 2\n-\n-  mv foo/bar/baz/dir-to-move foo/moved-dir\n-  ls -lah foo | grep bar | wc -l | grep 1\n-  ls -lah foo | grep moved-dir | wc -l | grep 1\n-  ls -lah foo/bar/baz | wc -l | grep 3 # total / . / ...\n-  ls -lah foo/moved-dir | grep dir-in-moved-dir | wc -l | grep 1\n-\n-  # Check that files exist after move\n-  ls -lah foo/moved-dir/file-in-moved-dir-1\n-  ls -lah foo/moved-dir/file-in-moved-dir-2\n-  ls -lah foo/moved-dir/dir-in-moved-dir/a/in-a\n-  ls -lah foo/moved-dir/dir-in-moved-dir/b/in-b\n-\n-  # Check that the file doesn't exist at it's previous location\n-  ls -lah foo/bar/baz | wc -l | grep 3\n-\n-  # Cleanup\n-  rm -rf *\n-\n-  # Rename test\n-  echo \"f1\" > f1\n-  echo \"f2\" > f2\n-  ls -lah | grep f1\n-  ls -lah | grep f2\n-  ls -lah | wc -l | grep 5\n-  mv f2 f1\n-  grep \"f2\" f1\n-  ls -lah | wc -l | grep 4\n-}\n-\n-# Run in root (remote storage)\n-runTests\n-\n-# Run in node_modules (local files)\n-mkdir node_modules && cd node_modules\n-runTests\n-\n-echo \"~~~ OK!\"\n",
    "diff --git a/client/fuse-client/inode/store.go b/client/fuse-client/inode/store.go\ndeleted file mode 100644\nindex af68864..0000000\n--- a/client/fuse-client/inode/store.go\n+++ /dev/null\n@@ -1,202 +0,0 @@\n-package inode\n-\n-import (\n-\t\"bazil.org/fuse/fs\"\n-\t\"errors\"\n-\t\"fmt\"\n-\t\"log\"\n-\t\"sync\"\n-)\n-\n-type Node struct {\n-\tParent   uint64\n-\tName     string\n-\tChildren map[string]uint64\n-\tFuseNode fs.Node\n-}\n-\n-type Store struct {\n-\tmx      *sync.RWMutex\n-\tseq     uint64\n-\tentries map[uint64]*Node\n-}\n-\n-var ChildNotFoundErr = errors.New(\"no such node under parent\")\n-var NotFoundErr = errors.New(\"no such node\")\n-var ParentDoesNotHaveChildrenErr = errors.New(\"parent doesn't have children\")\n-\n-func NewInodeStore() *Store {\n-\tc := &Store{\n-\t\tmx:      &sync.RWMutex{},\n-\t\tseq:     0,\n-\t\tentries: make(map[uint64]*Node),\n-\t}\n-\troot := &Node{\n-\t\tParent:   0,\n-\t\tName:     \"\",\n-\t\tChildren: nil,\n-\t}\n-\tc.entries[0] = root\n-\treturn c\n-}\n-\n-// callers need to have a lock on c.mx\n-func (c *Store) allParents(acc []string, inode uint64) ([]string, error) {\n-\t// Root terminates recursion\n-\tif inode == 1 {\n-\t\treturn acc, nil\n-\t}\n-\tn, ok := c.entries[inode]\n-\tif !ok {\n-\t\treturn nil, errors.New(\"node doesn't exist\")\n-\t}\n-\treturn c.allParents(append(acc, n.Name), n.Parent)\n-}\n-\n-func (c *Store) Move(inode uint64, newParent uint64, newName string) error {\n-\tc.mx.Lock()\n-\tdefer c.mx.Unlock()\n-\n-\te, ok := c.entries[inode]\n-\tif !ok {\n-\t\treturn errors.New(\"entry to move doesn't exist\")\n-\t}\n-\n-\toldParent, ok := c.entries[e.Parent]\n-\tif !ok {\n-\t\treturn errors.New(\"nodes parent doesn't exist\")\n-\t}\n-\tdelete(oldParent.Children, e.Name)\n-\n-\tif err := c.addToParent(newParent, inode, newName); err != nil {\n-\t\treturn err\n-\t}\n-\n-\tc.entries[inode].Parent = newParent\n-\tc.entries[inode].Name = newName\n-\treturn nil\n-}\n-\n-func (c *Store) Add(parent uint64, name string, fsnode fs.Node) (uint64, error) {\n-\tc.mx.Lock()\n-\tdefer c.mx.Unlock()\n-\n-\tinode := c.seq + 1\n-\n-\tif err := c.addToParent(parent, inode, name); err != nil {\n-\t\treturn 0, err\n-\t}\n-\n-\tc.entries[inode] = &Node{\n-\t\tParent:   parent,\n-\t\tName:     name,\n-\t\tChildren: nil,\n-\t\tFuseNode: fsnode,\n-\t}\n-\n-\tc.seq++\n-\treturn inode, nil\n-}\n-\n-func (c *Store) AddRoot(fsnode fs.Node) {\n-\tc.mx.Lock()\n-\tdefer c.mx.Unlock()\n-\tc.entries[0] = &Node{\n-\t\tFuseNode: fsnode,\n-\t}\n-}\n-\n-func (c *Store) Remove(nodeId uint64) error {\n-\tc.mx.Lock()\n-\tdefer c.mx.Unlock()\n-\n-\tn, ok := c.entries[nodeId]\n-\tif !ok {\n-\t\tlog.Println(\"tried to remove node that doesn't exist\")\n-\t\treturn nil\n-\t}\n-\n-\tp, ok := c.entries[n.Parent]\n-\tif !ok {\n-\t\treturn errors.New(\"nodes parent doesn't exist\")\n-\t}\n-\n-\tdelete(p.Children, n.Name)\n-\tdelete(c.entries, nodeId)\n-\treturn nil\n-}\n-\n-func (c *Store) GetChildren(inode uint64) ([]uint64, error) {\n-\tc.mx.RLock()\n-\tdefer c.mx.RUnlock()\n-\n-\tn, ok := c.entries[inode]\n-\tif !ok {\n-\t\treturn nil, NotFoundErr\n-\t}\n-\n-\tif n.Children == nil {\n-\t\treturn []uint64{}, ParentDoesNotHaveChildrenErr\n-\t}\n-\n-\tvar out []uint64\n-\tfor _, val := range n.Children {\n-\t\tout = append(out, val)\n-\t}\n-\treturn out, nil\n-}\n-\n-func (c *Store) LookupChild(inode uint64, childName string) (uint64, error) {\n-\tc.mx.RLock()\n-\tdefer c.mx.RUnlock()\n-\n-\tp, ok := c.entries[inode]\n-\tif !ok {\n-\t\treturn 0, NotFoundErr\n-\t}\n-\tif p.Children == nil {\n-\t\treturn 0, ParentDoesNotHaveChildrenErr\n-\t}\n-\tnodeId, ok := p.Children[childName]\n-\tif !ok {\n-\t\treturn 0, ChildNotFoundErr\n-\t}\n-\treturn nodeId, nil\n-}\n-\n-// callers need to have a lock on c.mx\n-func (c *Store) addToParent(parentID uint64, childID uint64, childName string) error {\n-\tp, ok := c.entries[parentID]\n-\tif !ok {\n-\t\treturn errors.New(fmt.Sprintf(\"parent doesn't exist parent=%d child=%d\", parentID, childID))\n-\t}\n-\tif p.Children == nil {\n-\t\tp.Children = make(map[string]uint64)\n-\t}\n-\tp.Children[childName] = childID\n-\treturn nil\n-}\n-\n-func (c *Store) GetFuseNode(inode uint64) (fs.Node, error) {\n-\tc.mx.RLock()\n-\tdefer c.mx.RUnlock()\n-\n-\tn, ok := c.entries[inode]\n-\tif !ok {\n-\t\treturn nil, NotFoundErr\n-\t}\n-\n-\treturn n.FuseNode, nil\n-}\n-\n-func (c *Store) Get(inode uint64) (*Node, error) {\n-\tc.mx.RLock()\n-\tdefer c.mx.RUnlock()\n-\n-\tn, ok := c.entries[inode]\n-\tif !ok {\n-\t\treturn nil, NotFoundErr\n-\t}\n-\n-\treturn n, nil\n-}\n",
    "diff --git a/client/fuse-client/inode/store_test.go b/client/fuse-client/inode/store_test.go\ndeleted file mode 100644\nindex 777e729..0000000\n--- a/client/fuse-client/inode/store_test.go\n+++ /dev/null\n@@ -1,113 +0,0 @@\n-package inode\n-\n-import (\n-\t\"github.com/stretchr/testify/assert\"\n-\t\"testing\"\n-)\n-\n-func TestAddEntryInRoot(t *testing.T) {\n-\tt.SkipNow()\n-\tc := NewInodeStore()\n-\tinode, err := c.Add(1, \"foo\", nil)\n-\tassert.Nil(t, err)\n-\tassert.Equal(t, uint64(11), inode)\n-\tassert.Equal(t, \"foo\", c.entries[inode].Name)\n-\tassert.Equal(t, uint64(11), c.entries[uint64(1)].Children[\"foo\"])\n-}\n-\n-func TestAddEntryToExisting(t *testing.T) {\n-\tt.SkipNow()\n-\tc := NewInodeStore()\n-\tparent, _ := c.Add(1, \"foo\", nil)\n-\tinode, err := c.Add(parent, \"bar\", nil)\n-\tassert.Nil(t, err)\n-\tassert.Equal(t, uint64(12), inode)\n-\tassert.Equal(t, \"bar\", c.entries[inode].Name)\n-\tassert.Equal(t, uint64(12), c.entries[parent].Children[\"bar\"])\n-}\n-\n-func TestRemoveEntry(t *testing.T) {\n-\tt.SkipNow()\n-\tc := NewInodeStore()\n-\tparent, _ := c.Add(1, \"foo\", nil)\n-\tinode, _ := c.Add(parent, \"bar\", nil)\n-\terr := c.Remove(inode)\n-\tassert.Nil(t, err)\n-\tassert.Nil(t, c.entries[inode])\n-\t_, ok := c.entries[parent].Children[\"bar\"]\n-\tassert.False(t, ok)\n-}\n-\n-func TestGetChildren(t *testing.T) {\n-\tt.SkipNow()\n-\tc := NewInodeStore()\n-\tparent, _ := c.Add(1, \"foo\", nil)\n-\ta, err := c.Add(parent, \"bar\", nil)\n-\tassert.Nil(t, err)\n-\tb, err := c.Add(parent, \"baz\", nil)\n-\tassert.Nil(t, err)\n-\tchildren, err := c.GetChildren(parent)\n-\tassert.Nil(t, err)\n-\tassert.ElementsMatch(t, []uint64{a, b}, children)\n-}\n-\n-func TestMove(t *testing.T) {\n-\tt.SkipNow()\n-\tc := NewInodeStore()\n-\tparent, _ := c.Add(1, \"foo\", nil)\n-\tinode, _ := c.Add(parent, \"bar\", nil)\n-\terr := c.Move(inode, uint64(1), \"bar\")\n-\tassert.Nil(t, err)\n-\tassert.NotNil(t, c.entries[inode])\n-\t_, ok := c.entries[parent].Children[\"bar\"]\n-\tassert.False(t, ok)\n-\tassert.Equal(t, inode, c.entries[uint64(1)].Children[\"bar\"])\n-}\n-\n-func TestMoveRenaming(t *testing.T) {\n-\tt.SkipNow()\n-\tc := NewInodeStore()\n-\tparent, _ := c.Add(1, \"foo\", nil)\n-\tinode, _ := c.Add(parent, \"bar\", nil)\n-\terr := c.Move(inode, parent, \"baz\")\n-\tassert.Nil(t, err)\n-\tassert.NotNil(t, c.entries[inode])\n-\t_, ok := c.entries[parent].Children[\"bar\"]\n-\tassert.False(t, ok)\n-\tassert.Equal(t, inode, c.entries[parent].Children[\"baz\"])\n-}\n-\n-func TestMoveRenamingTwice(t *testing.T) {\n-\tt.SkipNow()\n-\troot := uint64(1)\n-\tc := NewInodeStore()\n-\ti, _ := c.Add(root, \"foo.lock\", nil)\n-\terr := c.Move(i, root, \"foo\")\n-\tassert.Nil(t, err)\n-\t_, ok := c.entries[root].Children[\"foo.lock\"]\n-\tassert.False(t, ok)\n-\tassert.Equal(t, \"foo\", c.entries[i].Name)\n-\tassert.Equal(t, i, c.entries[root].Children[\"foo\"])\n-\n-\t// New lock file\n-\tiNew, err := c.Add(root, \"foo.lock\", nil)\n-\tassert.Nil(t, err)\n-\terr = c.Move(iNew, root, \"foo\")\n-\tassert.Nil(t, err)\n-\t_, ok = c.entries[root].Children[\"foo.lock\"]\n-\tassert.False(t, ok)\n-\tassert.Equal(t, \"foo\", c.entries[i].Name)\n-\t// Foo now points to the new inode\n-\tassert.Equal(t, iNew, c.entries[root].Children[\"foo\"])\n-}\n-\n-func TestLookupChild(t *testing.T) {\n-\tt.SkipNow()\n-\tc := NewInodeStore()\n-\tparent, _ := c.Add(1, \"foo\", nil)\n-\t_, _ = c.Add(parent, \"bar\", nil)\n-\tinode, _ := c.Add(parent, \"baz\", nil)\n-\tlookedUpInode, err := c.LookupChild(parent, \"baz\")\n-\tassert.Nil(t, err)\n-\tassert.Equal(t, inode, lookedUpInode)\n-}\n",
    "diff --git a/client/fuse-client/local/local.go b/client/fuse-client/local/local.go\ndeleted file mode 100644\nindex a918168..0000000\n--- a/client/fuse-client/local/local.go\n+++ /dev/null\n@@ -1,191 +0,0 @@\n-package local\n-\n-import (\n-\t\"fmt\"\n-\t\"io/ioutil\"\n-\t\"log\"\n-\tfileproto \"mash/api/files\"\n-\tmashfuse \"mash/client/fuse-client/workspace\"\n-\t\"mash/pkg/filesystem/common\"\n-\t\"os\"\n-\t\"path\"\n-)\n-\n-type localreadwriter struct {\n-\tbasedir string\n-}\n-\n-var _ mashfuse.WorkspaceReadWriter = (*localreadwriter)(nil)\n-\n-func NewLocalReadWriter(baseDir string) mashfuse.WorkspaceReadWriter {\n-\tlog.Println(\"BASEDIR\", baseDir)\n-\terr := os.MkdirAll(baseDir, os.ModeDir|0755)\n-\tif err != nil {\n-\t\t// TODO\n-\t\tpanic(err)\n-\t}\n-\treturn &localreadwriter{basedir: baseDir}\n-}\n-\n-func (l *localreadwriter) ReadFile(dir, file string) (*fileproto.File, error) {\n-\tp := path.Join(l.basedir, dir, file)\n-\tdirPath := path.Join(l.basedir, dir)\n-\n-\tfp, err := os.Open(p)\n-\tif err != nil {\n-\t\tlog.Println(err)\n-\t\treturn nil, err\n-\t}\n-\tdefer fp.Close()\n-\n-\treturn common.FileFromFp(dirPath, fp)\n-}\n-\n-func (l *localreadwriter) ListDir(dir string) ([]*fileproto.File, error) {\n-\tp := path.Join(l.basedir, dir)\n-\tfiles, err := ioutil.ReadDir(p)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tres := make([]*fileproto.File, len(files))\n-\tfor k, stat := range files {\n-\t\tres[k] = common.FileFromInfo(p, stat)\n-\t}\n-\treturn res, nil\n-}\n-\n-func (l *localreadwriter) createDirIfNotExists(dir string) error {\n-\tp := path.Join(l.basedir, dir)\n-\n-\t// Make sure that all parent dirs exist\n-\terr := os.MkdirAll(p, 0777|os.ModeDir)\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"writefile parents failed: %w\", err)\n-\t}\n-\treturn nil\n-}\n-\n-func (l *localreadwriter) WriteFile(dir, file string, data []byte, offset uint64) (uint64, error) {\n-\tif err := l.createDirIfNotExists(dir); err != nil {\n-\t\treturn 0, err\n-\t}\n-\n-\tp := path.Join(l.basedir, dir, file)\n-\n-\tfp, err := os.OpenFile(p, os.O_WRONLY, 0)\n-\tif err != nil {\n-\t\treturn 0, fmt.Errorf(\"open failed: %w\", err)\n-\t}\n-\tdefer fp.Close()\n-\n-\t_, err = fp.WriteAt(data, int64(offset))\n-\tif err != nil {\n-\t\treturn 0, fmt.Errorf(\"writeat failed: %w\", err)\n-\t}\n-\n-\terr = fp.Truncate(int64(offset) + int64(len(data)))\n-\tif err != nil {\n-\t\treturn 0, fmt.Errorf(\"truncate failed: %w\", err)\n-\t}\n-\n-\tst, err := fp.Stat()\n-\tif err != nil {\n-\t\treturn 0, fmt.Errorf(\"stat failed: %w\", err)\n-\t}\n-\n-\treturn uint64(st.Size()), nil\n-}\n-\n-func (l *localreadwriter) CreateFile(dir, file string, mode os.FileMode) error {\n-\tif err := l.createDirIfNotExists(dir); err != nil {\n-\t\treturn err\n-\t}\n-\n-\tp := path.Join(l.basedir, dir, file)\n-\n-\tfp, err := os.Create(p)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tdefer fp.Close()\n-\n-\terr = os.Chmod(p, mode)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\treturn nil\n-}\n-\n-func (l *localreadwriter) SetFileMode(dir, file string, mode os.FileMode) (err error) {\n-\tp := path.Join(l.basedir, dir, file)\n-\treturn os.Chmod(p, mode)\n-}\n-\n-func (l *localreadwriter) SetFileSize(dir, file string, size uint64) (err error) {\n-\tp := path.Join(l.basedir, dir, file)\n-\treturn os.Truncate(p, int64(size))\n-}\n-\n-func (l *localreadwriter) DeleteFile(dir, file string) error {\n-\tp := path.Join(l.basedir, dir, file)\n-\terr := os.Remove(p)\n-\tif err != nil && os.IsNotExist(err) {\n-\t\treturn nil\n-\t}\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-\n-func (l *localreadwriter) Rename(oldDir, oldName, newDir, newName string) error {\n-\told := path.Join(l.basedir, oldDir, oldName)\n-\tnew := path.Join(l.basedir, newDir, newName)\n-\n-\tif err := l.createDirIfNotExists(newDir); err != nil {\n-\t\treturn err\n-\t}\n-\t_ = os.RemoveAll(new)\n-\treturn os.Rename(old, new)\n-}\n-\n-func (l *localreadwriter) CreateDir(dir, file string, mode os.FileMode) error {\n-\t// Make sure that all parent dirs exist\n-\terr := os.MkdirAll(path.Join(l.basedir, dir, file), mode)\n-\tif err != nil && os.IsExist(err) {\n-\t\treturn nil\n-\t}\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-\n-func (l *localreadwriter) DeleteDir(dir, file string) error {\n-\tp := path.Join(l.basedir, dir, file)\n-\terr := os.Remove(p)\n-\tif err != nil && os.IsNotExist(err) {\n-\t\treturn nil\n-\t}\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-\n-func (l *localreadwriter) CreateLink(dir string, name string, target string) error {\n-\tp := path.Join(l.basedir, dir, name)\n-\treturn os.Symlink(target, p)\n-}\n-\n-func (l *localreadwriter) GetFileAttr(dir, name string) (*fileproto.FileStat, error) {\n-\tp := path.Join(l.basedir, dir, name)\n-\tstat, err := os.Stat(p)\n-\tif err != nil {\n-\t\tlog.Println(err)\n-\t\treturn nil, err\n-\t}\n-\treturn common.GrpcStat(stat), nil\n-}\n",
    "diff --git a/client/fuse-client/workspace/workspace.go b/client/fuse-client/workspace/workspace.go\ndeleted file mode 100644\nindex 7d4d089..0000000\n--- a/client/fuse-client/workspace/workspace.go\n+++ /dev/null\n@@ -1,29 +0,0 @@\n-package fuse\n-\n-import (\n-\tfileproto \"mash/api/files\"\n-\t\"os\"\n-)\n-\n-type WorkspaceReader interface {\n-\tReadFile(dir, file string) (*fileproto.File, error)\n-\tListDir(dir string) ([]*fileproto.File, error)\n-\tGetFileAttr(dir string, name string) (*fileproto.FileStat, error)\n-}\n-\n-type WorkspaceWriter interface {\n-\tWriteFile(dir, file string, data []byte, offset uint64) (uint64, error)\n-\tCreateFile(dir, file string, mode os.FileMode) error\n-\tSetFileMode(dir, file string, mode os.FileMode) (err error)\n-\tSetFileSize(dir, file string, size uint64) (err error)\n-\tDeleteFile(dir, file string) error\n-\tRename(oldDir, oldName, newDir, newName string) error\n-\tCreateDir(dir, file string, mode os.FileMode) error\n-\tDeleteDir(dir, file string) error\n-\tCreateLink(dir string, name string, target string) error\n-}\n-\n-type WorkspaceReadWriter interface {\n-\tWorkspaceReader\n-\tWorkspaceWriter\n-}\n",
    "diff --git a/mash.go b/cmd/api/mash.go\nsimilarity index 100%\nrename from mash.go\nrename to cmd/api/mash.go\n"
  ]
}